Lab1  
1. Создать вектор (одномерный массив) размера 10, заполненный 
единицами.
2. Создать вектор (одномерный массив) со значениями от 10 до 49
3. Создать вектор (одномерный массив) размера 10. Заполнить его 
случайными значениями. Найти индексы ненулевых элементов 
4. Создать матрицу (двумерный массив) 3x3 со значениями от 0 до 8
5. Создать 8x8 матрицу и заполнить её в шахматном порядке, используя 
функцию tile
6. Создать вектор (одномерный массив) размера 10. Заполнить его 
случайными значениями. Заменить минимальный элемент на ноль
7. Создать вектор (одномерный массив) размера 100. Заполнить его 
случайными значениями. Найти наиболее частое значение в массиве
8. Создать матрицу. Отнять среднее из каждой строки в матрице
9. Создать матрицу. Поменять две строки в матрице
10. Создать вектор (одномерный массив) размера 10. Заполнить его 
случайными значениями. Найти n наибольших значений в векторе
11. Создать 5x5 матрицу со значениями в строках от 1 до 5.
12. Создать две матрицы 4x4 и 4x4. Найти их произведение. Найти 
диагональные элементы произведения матриц
import numpy as np



# 1. Создать вектор размера 10, заполненный единицами
vector1 = np.ones(10)
print(vector1)

# 2. Создать вектор со значениями от 10 до 49
vector2 = np.arange(10, 50)
print(vector2)

# 3. Создать вектор размера 10 со случайными значениями, найти индексы ненулевых элементов
vector3 = np.random.randint(-5, 6, 10) 
print("Вектор:", vector3)
nonzero_indices = np.nonzero(vector3)[0]
print("Индексы ненулевых элементов:", nonzero_indices)

# 4. Создать матрицу 3x3 со значениями от 0 до 8
matrix4 = np.arange(9).reshape(3, 3)
print(matrix4)

# 5. Создать 8x8 матрицу в шахматном порядке с помощью tile
chess_base = np.array([[0, 1], [1, 0]])
matrix5 = np.tile(chess_base, (4, 4))
print(matrix5)

# 6. Заменить минимальный элемент на ноль
vector6 = np.random.randint(0,100,10)
print("Исходный вектор:", vector6)
min_index = np.argmin(vector6)
vector6[min_index] = 0
print("Вектор после замены:", vector6)
print("Минимальный элемент был на позиции", min_index)

# 7. Найти наиболее частое значение в массиве из 100 элементов
vector7 = np.random.randint(0,100,100)  
print("Исходный вектор:", vector7)
unique_values, counts = np.unique(vector7, return_counts=True)
most_frequent_index = np.argmax(counts)
most_frequent_value = unique_values[most_frequent_index]
most_frequent_count = counts[most_frequent_index]
print(f"\nНаиболее частое значение: {most_frequent_value}")
print(f"Оно встречается {most_frequent_count} раз(а)")

# 8. Отнять среднее из каждой строки в матрице
matrix = np.array([[1, 2, 3, 4],
                   [5, 6, 7, 8],
                   [9, 10, 11, 12]])
print("Исходная матрица:")
print(matrix)
mean_value = np.mean(matrix)
print(f"\nСреднее значение всего массива: {mean_value}")
result = matrix - mean_value
print("\nМатрица после вычитания среднего:")
print(result)


# 9. Поменять две строки в матрице
matrix9 = np.arange(20).reshape(5, 4)
print("Исходная матрица:")
print(matrix9)
matrix9[[1, 2]] = matrix9[[2, 1]]
print("\nМатрица после замены строк 1 и 2:")
print(matrix9)

# 10. Найти n наибольших значений в векторе
vector10 = np.random.randint(0,100,10)
n = 3
print("Вектор:", vector10)
largest_indices = np.argsort(vector10)[-n:][::-1]
largest_values = vector10[largest_indices]
print(f"{n} наибольших значения:", largest_values)


# 11. Создать 5x5 матрицу со значениями в строках от 1 до 5
matrix11 = np.tile(np.arange(1, 6), (5, 1))
print(matrix11)

# 12. Умножение матриц и нахождение диагональных элементов
matrix12_a = np.random.randint(1, 10, size=(4, 4))
matrix12_b = np.random.randint(1, 10, size=(4, 4))
print("Матрица A:")
print(matrix12_a)
print("\nМатрица B:")
print(matrix12_b)
product = np.dot(matrix12_a, matrix12_b)
print("\nПроизведение A × B:")
print(product)
diagonal = np.diag(product)
print("\nДиагональные элементы произведения:", diagonal)

Lab2
Датасет AirQualityUCI, содержит информацию о различных метеорологических 
показателях и уровнях загрязнения воздуха в одном из итальянских городов. 
В датасете представлены следующие признаки:
1. Дата - дата измерения информации.
2. Время - время измерения информации.
3. CO(GT) - уровень концентрации оксида углерода в мг/м³ (целевая переменная).
4. PT08.S1(CO) - уровень концентрации оксида олова в мкг/м³.
5. NMHC(GT) - уровень общих неуглеводородных компонентов в мкг/м³.
6. C6H6(GT) - уровень концентрации бензола в мкг/м³.
7. PT08.S2(NMHC) - уровень концентрации оксидов азота в мкг/м³.
8. NOx(GT) - уровень концентрации оксидов азота в ппб (частей на миллиард).
9. PT08.S3(NOx) - уровень концентрации осиных оксидов в мкг/м³.
10. NO2(GT) - уровень концентрации диоксида азота в мкг/м³.
11. PT08.S4(NO2) - уровень концентрации оксидов углерода в мкг/м³.
12. PT08.S5(O3) - уровень концентрации озона в мкг/м³.
13. T - температура в °C.
14. RH - относительная влажность в %.
15. AH - высота водяного пара в г/м³.
1. Загрузите данные из файла "AirQualityUCI.csv" в DataFrame pandas. 
2. Выведите первые и последние 5 строк DataFrame
3. Выведите общее количество строк (измерений) и столбцов (признаков) в DataFrame.
4. Выведите список названий всех столбцов в DataFrame.
5. Проверьте, есть ли в DataFrame пропущенные значения. Выведите количество 
пропущенных значений для каждого столбца.
6. Выведите основные статистические характеристики (среднее, медиана, стандартное 
отклонение, минимум, максимум, квартили) для числовых столбцов DataFrame.
7. Выведите сводную информацию о DataFrame, включая типы данных столбцов, 
количество непустых значений и объем занимаемой памяти.
8. Какие уникальные значения принимает признак "T" (температура)? Выведите все 
Машинное обучение - 2026 – ПМ43-2 группа
уникальные значения, их количество и частоту встречаемости.
9. Выведите строки DataFrame, где уровень концентрации оксида углерода (CO(GT)) 
превышает 3 мг/м³, а температура (T) ниже 20°C.
10. Создайте новый признак "NOx_CO_ratio", который будет представлять собой 
отношение уровня концентрации оксидов азота (NOx(GT)) к уровню концентрации оксида 
углерода (CO(GT)).
11. новый размер DataFrame после добавления нового столбца.
12. Какое значение температуры (T) встречается в датасете чаще всего?
13. Найдите количество строк, в которых отсутствуют данные о концентрации бензола 
(C6H6(GT)). Выведите информацию об этих строках. (пропущенные значения могут быть 
представлены как -200)
14. Найдите минимальный уровень концентрации оксида углерода (CO(GT)) при 
температуре выше 25°C. Выведите информацию об этих измерениях.
15. Найдите количество измерений, в которых относительная влажность (RH) превышает 
90%. Выведите информацию об этих измерениях.
16. Найдите разницу между средним уровнем концентрации оксида углерода (CO(GT)) 
при температуре выше и ниже 20°C. Округлите результат до двух знаков после запятой.
17. Создайте признак "High_Ozone", который будет равен 1, если уровень концентрации 
озона (PT08.S5(O3)) превышает среднее значение, и 0 в противном случае.
18. Выведите наиболее распространенный уровень концентрации оксидов азота 
(NOx(GT)).
19. Найдите количество измерений, в которых и уровень концентрации бензола 
(C6H6(GT)), и уровень концентрации оксидов азота (NOx(GT)) превышают свои средние 
значения.
20. Найдите максимальную температуру (T) среди измерений, где уровень концентрации 
диоксида азота (NO2(GT)) ниже 50 мкг/м³.
21. Найдите количество измерений, в которых уровень концентрации оксида углерода 
(CO(GT)) выше среднего значения по датасету. Выведите информацию об этих 
измерениях.
22. Разделите данные на две группы: измерения, сделанные при температуре выше 
среднего значения, и измерения, сделанные при температуре ниже среднего значения. 
Сравните средний уровень концентрации бензола (C6H6(GT)) в этих двух группах
import pandas as pd
import numpy as np
в файлах Colab  будет папка контент,AirQualityUCI.csv нужно перенести туда.
# 1. Загрузите данные из файла "AirQualityUCI.csv" в DataFrame pandas
df = pd.read_csv('AirQualityUCI.csv', sep=';', decimal=',')

# 2. Выведите первые и последние 5 строк DataFrame
print("="*60)
print("2. Первые 5 строк:")
print(df.head())
print("\nПоследние 5 строк:")
print(df.tail())

# 3. Выведите общее количество строк (измерений) и столбцов (признаков) в DataFrame
print("\n" + "="*60)
print("3. Размерность данных:")
print(f"Количество строк: {df.shape[0]}")
print(f"Количество столбцов: {df.shape[1]}")

# 4. Выведите список названий всех столбцов в DataFrame
print("\n" + "="*60)
print("4. Названия столбцов:")
print(df.columns.tolist())

# 5. Проверьте, есть ли в DataFrame пропущенные значения
print("\n" + "="*60)
print("5. Пропущенные значения:")
missing_values = df.isnull().sum()
print(missing_values[missing_values > 0])

# 6. Основные статистические характеристики для числовых столбцов
print("\n" + "="*60)
print("6. Статистические характеристики:")
print(df.describe())

# 7. Сводная информация о DataFrame
print("\n" + "="*60)
print("7. Информация о DataFrame:")
print(df.info())

# 8. Уникальные значения признака "T" (температура)
print("\n" + "="*60)
print("8. Уникальные значения температуры:")
print(f"Количество уникальных значений: {df['T'].nunique()}")
print(f"Уникальные значения:\n{df['T'].unique()[:10]}")  # первые 10
print(f"\nЧастота встречаемости:\n{df['T'].value_counts().head(10)}")

# 9. Строки, где CO(GT) > 3 мг/м³ и T < 20°C
print("\n" + "="*60)
print("9. Строки с CO(GT) > 3 и T < 20:")
# Убираем возможные -200 в данных
df_clean = df.copy()
for col in df.columns:
    if df[col].dtype in ['int64', 'float64']:
        df_clean[col] = df[col].replace(-200, np.nan)

filtered_rows = df_clean[(df_clean['CO(GT)'] > 3) & (df_clean['T'] < 20)]
print(f"Количество таких строк: {len(filtered_rows)}")
if len(filtered_rows) > 0:
    print(filtered_rows[['Date', 'Time', 'CO(GT)', 'T']].head())

# 10. Создайте новый признак "NOx_CO_ratio"
print("\n" + "="*60)
print("10. Создание нового признака NOx_CO_ratio:")
df_clean['NOx_CO_ratio'] = df_clean['NOx(GT)'] / df_clean['CO(GT)']
print("Новый столбец добавлен")

# 11. Новый размер DataFrame после добавления нового столбца
print("\n" + "="*60)
print("11. Новый размер DataFrame:")
print(f"Строк: {df_clean.shape[0]}, Столбцов: {df_clean.shape[1]}")

# 12. Какое значение температуры (T) встречается в датасете чаще всего?
print("\n" + "="*60)
print("12. Наиболее частая температура:")
most_common_temp = df_clean['T'].mode()[0]
temp_count = df_clean['T'].value_counts().iloc[0]
print(f"Температура {most_common_temp}°C встречается {temp_count} раз")

# 13. Строки с отсутствующими данными о концентрации бензола
print("\n" + "="*60)
print("13. Строки с отсутствующими данными о бензоле:")
# Ищем строки где C6H6(GT) равно -200 или NaN
missing_benzene = df[(df['C6H6(GT)'] == -200) | df['C6H6(GT)'].isnull()]
print(f"Количество строк: {len(missing_benzene)}")
if len(missing_benzene) > 0:
    print(missing_benzene[['Date', 'Time', 'C6H6(GT)']].head())

# 14. Минимальный CO(GT) при температуре выше 25°C
print("\n" + "="*60)
print("14. Минимальный CO(GT) при T > 25°C:")
high_temp_df = df_clean[df_clean['T'] > 25]
if len(high_temp_df) > 0:
    min_co = high_temp_df['CO(GT)'].min()
    min_co_rows = high_temp_df[high_temp_df['CO(GT)'] == min_co]
    print(f"Минимальное значение CO(GT): {min_co}")
    print(f"Количество измерений с таким значением: {len(min_co_rows)}")
    print(min_co_rows[['Date', 'Time', 'CO(GT)', 'T']].head())
else:
    print("Нет измерений с температурой выше 25°C")

# 15. Измерения с относительной влажностью > 90%
print("\n" + "="*60)
print("15. Измерения с RH > 90%:")
high_humidity = df_clean[df_clean['RH'] > 90]
print(f"Количество измерений: {len(high_humidity)}")
if len(high_humidity) > 0:
    print(high_humidity[['Date', 'Time', 'RH', 'T']].head())

# 16. Разница между средним CO(GT) при температуре выше и ниже 20°C
print("\n" + "="*60)
print("16. Разница средних CO(GT) при разной температуре:")
co_above_20 = df_clean[df_clean['T'] > 20]['CO(GT)'].mean()
co_below_20 = df_clean[df_clean['T'] <= 20]['CO(GT)'].mean()
difference = abs(co_above_20 - co_below_20)
print(f"Среднее CO(GT) при T > 20°C: {co_above_20:.2f}")
print(f"Среднее CO(GT) при T <= 20°C: {co_below_20:.2f}")
print(f"Разница: {difference:.2f}")

# 17. Создайте признак "High_Ozone"
print("\n" + "="*60)
print("17. Создание признака High_Ozone:")
ozone_mean = df_clean['PT08.S5(O3)'].mean()
df_clean['High_Ozone'] = (df_clean['PT08.S5(O3)'] > ozone_mean).astype(int)
print(f"Среднее значение озона: {ozone_mean:.2f}")
print(f"Высокий озон (1): {df_clean['High_Ozone'].sum()} измерений")
print(f"Низкий озон (0): {len(df_clean) - df_clean['High_Ozone'].sum()} измерений")

# 18. Наиболее распространенный уровень концентрации оксидов азота
print("\n" + "="*60)
print("18. Наиболее распространенный уровень NOx(GT):")
most_common_nox = df_clean['NOx(GT)'].mode()[0]
print(f"Наиболее распространенное значение: {most_common_nox}")

# 19. Измерения где C6H6(GT) и NOx(GT) превышают свои средние значения
print("\n" + "="*60)
print("19. Измерения с C6H6(GT) и NOx(GT) выше среднего:")
benzene_mean = df_clean['C6H6(GT)'].mean()
nox_mean = df_clean['NOx(GT)'].mean()
high_both = df_clean[(df_clean['C6H6(GT)'] > benzene_mean) & 
                     (df_clean['NOx(GT)'] > nox_mean)]
print(f"Количество измерений: {len(high_both)}")
print(f"Среднее C6H6(GT): {benzene_mean:.2f}")
print(f"Среднее NOx(GT): {nox_mean:.2f}")

# 20. Максимальная температура при NO2(GT) < 50
print("\n" + "="*60)
print("20. Максимальная температура при NO2(GT) < 50:")
low_no2_df = df_clean[df_clean['NO2(GT)'] < 50]
if len(low_no2_df) > 0:
    max_temp = low_no2_df['T'].max()
    max_temp_rows = low_no2_df[low_no2_df['T'] == max_temp]
    print(f"Максимальная температура: {max_temp}°C")
    print(f"Количество таких измерений: {len(max_temp_rows)}")
    print(max_temp_rows[['Date', 'Time', 'T', 'NO2(GT)']].head())
else:
    print("Нет измерений с NO2(GT) < 50")

# 21. Измерения где CO(GT) выше среднего
print("\n" + "="*60)
print("21. Измерения с CO(GT) выше среднего:")
co_mean = df_clean['CO(GT)'].mean()
high_co = df_clean[df_clean['CO(GT)'] > co_mean]
print(f"Среднее CO(GT): {co_mean:.2f}")
print(f"Количество измерений выше среднего: {len(high_co)}")
print(f"Процент от общего числа: {len(high_co)/len(df_clean)*100:.1f}%")
if len(high_co) > 0:
    print(high_co[['Date', 'Time', 'CO(GT)', 'T']].head())

# 22. Сравнение среднего C6H6(GT) при температуре выше и ниже среднего
print("\n" + "="*60)
print("22. Сравнение C6H6(GT) при разной температуре:")
temp_mean = df_clean['T'].mean()
above_temp_mean = df_clean[df_clean['T'] > temp_mean]
below_temp_mean = df_clean[df_clean['T'] <= temp_mean]

benzene_above = above_temp_mean['C6H6(GT)'].mean()
benzene_below = below_temp_mean['C6H6(GT)'].mean()

print(f"Средняя температура: {temp_mean:.2f}°C")
print(f"Среднее C6H6(GT) при T > {temp_mean:.2f}°C: {benzene_above:.2f}")
print(f"Среднее C6H6(GT) при T <= {temp_mean:.2f}°C: {benzene_below:.2f}")
print(f"Разница: {abs(benzene_above - benzene_below):.2f}")

# Дополнительно: сводка по результатам
print("\n" + "="*60)
print("Итоговая сводка:")
print("="*60)
print(f"1. Всего измерений: {df.shape[0]}")
print(f"2. Всего признаков: {df.shape[1]}")
print(f"3. Пропущенных значений: {df.isnull().sum().sum()}")
print(f"4. Диапазон температур: {df_clean['T'].min():.1f}°C - {df_clean['T'].max():.1f}°C")
print(f"5. Диапазон CO(GT): {df_clean['CO(GT)'].min():.2f} - {df_clean['CO(GT)'].max():.2f} мг/м³")
print(f"6. Средняя температура: {df_clean['T'].mean():.2f}°C")
print(f"7. Средний CO(GT): {df_clean['CO(GT)'].mean():.2f} мг/м³")
Машинное обучение - 2026 – ПМ43-2 группа
Лабораторная работа №3
Пакет matplotlib
Датасет AirQualityUCI, содержит информацию о различных метеорологических 
показателях и уровнях загрязнения воздуха в одном из итальянских городов. 
В датасете представлены следующие признаки:
1. Дата - дата измерения информации.
2. Время - время измерения информации.
3. CO(GT) - уровень концентрации оксида углерода в мг/м³ (целевая переменная).
4. PT08.S1(CO) - уровень концентрации оксида олова в мкг/м³.
5. NMHC(GT) - уровень общих неуглеводородных компонентов в мкг/м³.
6. C6H6(GT) - уровень концентрации бензола в мкг/м³.
7. PT08.S2(NMHC) - уровень концентрации оксидов азота в мкг/м³.
8. NOx(GT) - уровень концентрации оксидов азота в ппб (частей на миллиард).
9. PT08.S3(NOx) - уровень концентрации осиных оксидов в мкг/м³.
10. NO2(GT) - уровень концентрации диоксида азота в мкг/м³.
11. PT08.S4(NO2) - уровень концентрации оксидов углерода в мкг/м³.
12. PT08.S5(O3) - уровень концентрации озона в мкг/м³.
13. T - температура в °C.
14. RH - относительная влажность в %.
15. AH - высота водяного пара в г/м³.
1. Найдите количество наблюдений для каждого диапазона значений целевой переменной "CO(GT)" 
(уровень концентрации оксида углерода). Разбейте значения CO(GT) на несколько интервалов 
(например, с помощью pd.cut или pd.qcut) и примените метод plot к полученным данным, чтобы 
построить столбчатую диаграмму, показывающую распределение концентраций CO.
2. Постройте такую же столбчатую диаграмму, как в задаче 1, но используйте логарифмический 
масштаб для оси Y (количества наблюдений). Это поможет лучше визуализировать распределение, 
если есть очень большие различия в частоте встречаемости разных диапазонов концентраций CO.
3. Постройте две гистограммы по значениям признака "T" (температура) – одну для наблюдений, где 
уровень концентрации оксида углерода (CO(GT)) выше среднего, и другую – где он ниже среднего.
4. В задаче 3 подберите значение аргумента density=True в функции hist так, чтобы по вертикали 
графика была расположена не частота, а плотность распределения. Число бинов должно равняться 
20 для обеих гистограмм, а коэффициент alpha равным 0.5, чтобы гистограммы были 
полупрозрачными и не загораживали друг друга.
5. Создайте легенду с двумя значениями: "CO выше среднего" и "CO ниже среднего". Гистограмма 
для "CO выше среднего" должна быть красного цвета, а для "CO ниже среднего" - синего. Название 
горизонтальной оси – "Температура (°C)".
Машинное обучение - 2026 – ПМ43-2 группа
6. Аналогично изобразите гистограмму распределения уровня концентрации бензола (C6H6(GT)) 
относительно времени суток (можно выделить, например, утренние, дневные, вечерние и ночные 
часы на основе признака "Время").
7. Постройте гистограммы или boxplots для CO(GT) , разбив данные по времени суток (утром, днем, 
вечером, ночью).
8. Постройте несколько гистограмм или диаграмм рассеяния, показывающих зависимость 
концентраций разных загрязняющих веществ (например, CO(GT), C6H6(GT), NOx(GT)) от 
температуры (T). Это поможет оценить, как температура влияет на различные типы загрязнения.
9*. Постройте график с областями (area plot), показывающий изменение во времени нескольких 
показателей, например, концентрации разных веществ. Это позволит наглядно увидеть вклад 
каждого вещества в общий уровень загрязнения.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib

# Настройка стиля для графиков
plt.style.use('ggplot')
matplotlib.rcParams['figure.figsize'] = (12, 8)
matplotlib.rcParams['font.size'] = 12

# Загрузка и предобработка данных
print("Загрузка данных AirQualityUCI...")
try:
    df = pd.read_csv('AirQualityUCI.csv', sep=';', decimal=',')
    print("Данные успешно загружены")
except FileNotFoundError:
    print("Файл 'AirQualityUCI.csv' не найден. Создаем пример данных...")
    # Создаем пример данных для демонстрации
    np.random.seed(42)
    dates = pd.date_range('2024-01-01', periods=1000, freq='H')
    df = pd.DataFrame({
        'Date': dates.date,
        'Time': dates.time,
        'CO(GT)': np.random.gamma(2, 2, 1000),
        'C6H6(GT)': np.random.gamma(3, 1.5, 1000),
        'NOx(GT)': np.random.gamma(2.5, 3, 1000),
        'T': np.random.normal(20, 8, 1000),
        'RH': np.random.normal(60, 15, 1000),
        'AH': np.random.gamma(5, 2, 1000),
        'PT08.S5(O3)': np.random.gamma(4, 5, 1000),
        'NO2(GT)': np.random.gamma(3, 10, 1000)
    })

# Преобразование типов данных
for col in ['CO(GT)', 'C6H6(GT)', 'NOx(GT)', 'T', 'RH', 'AH', 'PT08.S5(O3)', 'NO2(GT)']:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce')

# Удаление пропущенных значений (где -200)
df = df.replace(-200, np.nan)
df = df.dropna()

print(f"Размер данных после очистки: {df.shape}")

# 1. Распределение CO(GT) по интервалам
print("\n1. Построение столбчатой диаграммы распределения CO(GT)")
# Создание интервалов
df['CO_range'] = pd.cut(df['CO(GT)'], bins=10)
co_distribution = df['CO_range'].value_counts().sort_index()

plt.figure(figsize=(14, 6))
co_distribution.plot(kind='bar', color='skyblue', edgecolor='black')
plt.title('Распределение концентрации CO(GT)', fontsize=16, fontweight='bold')
plt.xlabel('Диапазон CO(GT) (мг/м³)', fontsize=14)
plt.ylabel('Количество наблюдений', fontsize=14)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.savefig('co_distribution.png', dpi=150)
plt.show()

# 2. То же распределение в логарифмическом масштабе
print("\n2. То же распределение с логарифмическим масштабом")
plt.figure(figsize=(14, 6))
co_distribution.plot(kind='bar', color='lightcoral', edgecolor='black', logy=True)
plt.title('Распределение CO(GT) (логарифмическая шкала)', fontsize=16, fontweight='bold')
plt.xlabel('Диапазон CO(GT) (мг/м³)', fontsize=14)
plt.ylabel('Количество наблюдений (log)', fontsize=14)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.savefig('co_distribution_log.png', dpi=150)
plt.show()

# 3-5. Гистограммы температуры для CO выше и ниже среднего
print("\n3-5. Гистограммы температуры для разных групп CO")
co_mean = df['CO(GT)'].mean()
co_above = df[df['CO(GT)'] > co_mean]['T']
co_below = df[df['CO(GT)'] <= co_mean]['T']

plt.figure(figsize=(14, 8))
plt.hist([co_above, co_below], bins=20, density=True, alpha=0.5, 
         color=['red', 'blue'], label=['CO выше среднего', 'CO ниже среднего'])
plt.title('Распределение температуры для разных уровней CO', fontsize=16, fontweight='bold')
plt.xlabel('Температура (°C)', fontsize=14)
plt.ylabel('Плотность распределения', fontsize=14)
plt.legend(fontsize=12)
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig('temperature_histograms.png', dpi=150)
plt.show()

# 6. Распределение бензола по времени суток
print("\n6. Распределение бензола по времени суток")
# Создание категорий времени суток
def get_time_period(hour):
    if 6 <= hour < 12:
        return 'Утро'
    elif 12 <= hour < 18:
        return 'День'
    elif 18 <= hour < 24:
        return 'Вечер'
    else:
        return 'Ночь'

# Извлечение часа из времени
df['Hour'] = pd.to_datetime(df['Time'].astype(str)).dt.hour
df['Time_period'] = df['Hour'].apply(get_time_period)

plt.figure(figsize=(14, 8))
time_period_order = ['Утро', 'День', 'Вечер', 'Ночь']
for period in time_period_order:
    data = df[df['Time_period'] == period]['C6H6(GT)'].dropna()
    plt.hist(data, bins=20, alpha=0.5, label=period, density=True)

plt.title('Распределение бензола (C6H6(GT)) по времени суток', fontsize=16, fontweight='bold')
plt.xlabel('Концентрация бензола (мкг/м³)', fontsize=14)
plt.ylabel('Плотность распределения', fontsize=14)
plt.legend(fontsize=12)
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig('benzene_time_distribution.png', dpi=150)
plt.show()

# 7. Boxplots для CO(GT) по времени суток
print("\n7. Boxplots для CO(GT) по времени суток")
plt.figure(figsize=(14, 8))
co_by_time = [df[df['Time_period'] == period]['CO(GT)'].dropna() 
              for period in time_period_order]
bp = plt.boxplot(co_by_time, labels=time_period_order, patch_artist=True)

# Настройка цветов
colors = ['gold', 'lightgreen', 'lightcoral', 'lightskyblue']
for patch, color in zip(bp['boxes'], colors):
    patch.set_facecolor(color)
    patch.set_alpha(0.7)

plt.title('Распределение CO(GT) по времени суток', fontsize=16, fontweight='bold')
plt.xlabel('Время суток', fontsize=14)
plt.ylabel('Концентрация CO(GT) (мг/м³)', fontsize=14)
plt.grid(True, alpha=0.3, axis='y')
plt.tight_layout()
plt.savefig('co_boxplots.png', dpi=150)
plt.show()

# 8. Диаграммы рассеяния зависимости загрязнений от температуры
print("\n8. Диаграммы рассеяния зависимости загрязнений от температуры")
fig, axes = plt.subplots(2, 2, figsize=(16, 12))
pollutants = ['CO(GT)', 'C6H6(GT)', 'NOx(GT)', 'NO2(GT)']
colors = ['red', 'blue', 'green', 'purple']

for ax, pollutant, color in zip(axes.flat, pollutants, colors):
    ax.scatter(df['T'], df[pollutant], alpha=0.3, c=color, s=20)
    ax.set_xlabel('Температура (°C)', fontsize=12)
    ax.set_ylabel(f'{pollutant} (мкг/м³)', fontsize=12)
    ax.set_title(f'Зависимость {pollutant} от температуры', fontsize=14)
    ax.grid(True, alpha=0.3)
    
    # Добавление линии тренда
    z = np.polyfit(df['T'].dropna(), df[pollutant].dropna(), 1)
    p = np.poly1d(z)
    ax.plot(df['T'].sort_values(), p(df['T'].sort_values()), 
            "r--", alpha=0.8, linewidth=2, label=f'Тренд: {z[0]:.2f}x + {z[1]:.2f}')
    ax.legend(fontsize=10)

plt.suptitle('Зависимость концентрации загрязняющих веществ от температуры', 
             fontsize=16, fontweight='bold')
plt.tight_layout()
plt.savefig('pollution_temperature_scatter.png', dpi=150)
plt.show()

# 9*. График с областями (area plot) изменения показателей во времени
print("\n9. График с областями изменения показателей во времени")

# Создание временной метки
df['DateTime'] = pd.to_datetime(df['Date'].astype(str) + ' ' + df['Time'].astype(str))
df_sorted = df.sort_values('DateTime')

# Выбор показателей для графика
pollutants_area = ['CO(GT)', 'C6H6(GT)', 'NOx(GT)']
# Нормализация данных для лучшей визуализации
df_normalized = df_sorted.copy()
for pollutant in pollutants_area:
    df_normalized[pollutant] = (df_sorted[pollutant] - df_sorted[pollutant].min()) / \
                                (df_sorted[pollutant].max() - df_sorted[pollutant].min())

plt.figure(figsize=(16, 10))
plt.stackplot(df_normalized['DateTime'], 
              df_normalized['CO(GT)'].values,
              df_normalized['C6H6(GT)'].values,
              df_normalized['NOx(GT)'].values,
              labels=['CO(GT)', 'C6H6(GT)', 'NOx(GT)'],
              colors=['red', 'blue', 'green'],
              alpha=0.7)

plt.title('Изменение концентрации загрязняющих веществ во времени', 
          fontsize=16, fontweight='bold')
plt.xlabel('Дата и время', fontsize=14)
plt.ylabel('Нормализованная концентрация', fontsize=14)
plt.legend(loc='upper right', fontsize=12)
plt.grid(True, alpha=0.3)
plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('pollution_area_plot.png', dpi=150)
plt.show()

# Дополнительные визуализации для более полного анализа

print("\nДополнительные визуализации:")

# 10. Тепловая карта корреляций
print("10. Тепловая карта корреляций между показателями")
plt.figure(figsize=(12, 10))
correlation_matrix = df[pollutants_area + ['T', 'RH', 'AH']].corr()
im = plt.imshow(correlation_matrix, cmap='coolwarm', aspect='auto', vmin=-1, vmax=1)
plt.colorbar(im, label='Корреляция')
plt.xticks(range(len(correlation_matrix.columns)), correlation_matrix.columns, rotation=45, ha='right')
plt.yticks(range(len(correlation_matrix.columns)), correlation_matrix.columns)
plt.title('Тепловая карта корреляций между показателями', fontsize=16, fontweight='bold')

# Добавление значений корреляции на тепловую карту
for i in range(len(correlation_matrix.columns)):
    for j in range(len(correlation_matrix.columns)):
        plt.text(j, i, f'{correlation_matrix.iloc[i, j]:.2f}', 
                ha='center', va='center', fontsize=10)

plt.tight_layout()
plt.savefig('correlation_heatmap.png', dpi=150)
plt.show()

# 11. Временные ряды для ключевых показателей
print("11. Временные ряды для ключевых показателей")
fig, axes = plt.subplots(3, 1, figsize=(16, 12))

# Выбор подмножества данных для лучшей визуализации
sample_data = df_sorted.iloc[:200]  # Первые 200 наблюдений

for i, (ax, pollutant, color) in enumerate(zip(axes, pollutants_area, ['red', 'blue', 'green'])):
    ax.plot(sample_data['DateTime'], sample_data[pollutant], color=color, linewidth=1.5, alpha=0.7)
    ax.set_ylabel(f'{pollutant} (мкг/м³)', fontsize=12)
    ax.set_title(f'Временной ряд: {pollutant}', fontsize=14)
    ax.grid(True, alpha=0.3)
    ax.tick_params(axis='x', rotation=45)

axes[-1].set_xlabel('Дата и время', fontsize=12)
plt.suptitle('Временные ряды концентрации загрязняющих веществ', 
             fontsize=16, fontweight='bold')
plt.tight_layout()
plt.savefig('time_series.png', dpi=150)
plt.show()

# Вывод статистики
print("\nСтатистика по созданным графикам:")
print(f"1. Распределение CO(GT): {len(co_distribution)} интервалов")
print(f"2. Среднее значение CO(GT): {co_mean:.2f} мкг/м³")
print(f"3. Количество наблюдений с CO выше среднего: {len(co_above)}")
print(f"4. Количество наблюдений с CO ниже среднего: {len(co_below)}")
print(f"5. Распределение по времени суток:")
for period in time_period_order:
    count = len(df[df['Time_period'] == period])
    print(f"   {period}: {count} наблюдений")

print("\nВсе графики сохранены в файлы:")
print("- co_distribution.png")
print("- co_distribution_log.png")
print("- temperature_histograms.png")
print("- benzene_time_distribution.png")
print("- co_boxplots.png")
print("- pollution_temperature_scatter.png")
print("- pollution_area_plot.png")
print("- correlation_heatmap.png")
print("- time_series.png")
