# elliptic_curve_correct.py
import random
import math

# =========================================================
# Miller–Rabin (вероятностный тест простоты)
# =========================================================

def is_probable_prime(n, k=10):
    if n in (2, 3):
        return True
    if n < 2 or n % 2 == 0:
        return False

    # n-1 = d * 2^s
    d = n - 1
    s = 0
    while d % 2 == 0:
        d //= 2
        s += 1

    for _ in range(k):
        a = random.randrange(2, n - 1)
        x = pow(a, d, n)
        if x in (1, n - 1):
            continue
        for __ in range(s - 1):
            x = (x * x) % n
            if x == n - 1:
                break
        else:
            return False
    return True


def next_prime(start):
    p = start if start % 2 else start + 1
    while True:
        print("Тестируемое число", p)
        if is_probable_prime(p):
            return p
        print("Тест не пройден, число составное")
        p += 2


# =========================================================
# Эллиптическая кривая: y^2 = x^3 + x (mod p)
# =========================================================

O = None  # точка на бесконечности

def inv_mod(a, p):
    a %= p
    if a == 0:
        raise ZeroDivisionError("Обратного элемента не существует")
    return pow(a, p - 2, p)  # p простое


def add_points(P, Q, p):
    if P is None:
        return Q
    if Q is None:
        return P

    x1, y1 = P
    x2, y2 = Q

    # P + (-P) = O
    if x1 == x2 and (y1 + y2) % p == 0:
        return None

    if P != Q:
        lam = ((y2 - y1) * inv_mod(x2 - x1, p)) % p
    else:
        # удвоение: lam = (3x^2 + 1) / (2y)
        if y1 % p == 0:
            return None
        lam = ((3 * x1 * x1 + 1) * inv_mod(2 * y1, p)) % p

    x3 = (lam * lam - x1 - x2) % p
    y3 = (lam * (x1 - x3) - y1) % p
    return (x3, y3)


def mul(k, P, p):
    """Скалярное умножение (double-and-add)."""
    R = None
    A = P
    while k > 0:
        if k & 1:
            R = add_points(R, A, p)
        A = add_points(A, A, p)
        k >>= 1
    return R


def on_curve(P, p):
    if P is None:
        return True
    x, y = P
    return (y*y - (x*x*x + x)) % p == 0


def find_point(p):
    """Ищем любую точку на кривой перебором ."""
    for x in range(1, p):
        rhs = (x*x*x + x) % p
        for y in range(1, p):
            if (y*y) % p == rhs:
                return (x, y)
    return None


def point_order_if_divides_n(P, p, n):

    divisors = []
    for d in range(1, int(math.isqrt(n)) + 1):
        if n % d == 0:
            divisors.append(d)
            if d * d != n:
                divisors.append(n // d)
    divisors.sort()

    for d in divisors:
        if mul(d, P, p) is None:
            return d
    return n


# =========================================================
# main
# =========================================================

def main():
    start =131927  #  p = 131927
    p = next_prime(start)
    print("\nПростое число:", p)

    P = find_point(p)
    print("Найдена точка P:", P)
    print("P на кривой?", on_curve(P, p))

    # Удвоения: 2P,4P,...,128P
    Q = P
    for n in [2, 4, 8, 16, 32, 64, 128]:
        Q = add_points(Q, Q, p)
        print(f"{n}P = {Q}")
        if Q is None:
            order = point_order_if_divides_n(P, p, n)

            print(f"Достигнута бесконечно удаленная точка Порядок точки: {order}")
            break

    # пример из лабы
    P151 = mul(151, P, p)
    print("151P =", P151)


if __name__ == "__main__":
    main()
