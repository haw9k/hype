#rabin_miller

import random
import math


def fast_pow_mod(a, exponent, n, operation_name=""):
    """Быстрое возведение в степень по модулю с выводом шагов"""
    i = exponent
    p = 1
    a_k = a % n
    step = 1

    print(f"\n{operation_name} числа {a}:")
    print(f"{'k':>2} | {'a_k':>10} | {'i':>10} | {'s':>3} | {'p':>10}")
    print("-" * 45)

    while i > 0:
        s = i % 2
        if s == 1:
            p = (p * a_k) % n
        print(f"{step:>2} | {a_k:>10} | {i:>10} | {s:>3} | {p:>10}")
        a_k = (a_k * a_k) % n
        i = i // 2
        step += 1

    print(f"Итоговый результат: {p} ({a}^{exponent} mod {n})\n")
    return p


class PrimeGenerator:
    def __init__(self):
        # Генерируем малые простые числа до 200 для фильтрации
        self.small_primes = self._generate_small_primes(200)

    def _generate_small_primes(self, limit):
        """Генерирует список простых чисел до заданного предела"""
        sieve = [True] * (limit + 1)
        sieve[0] = sieve[1] = False

        for i in range(2, int(math.sqrt(limit)) + 1):
            if sieve[i]:
                for j in range(i * i, limit + 1, i):
                    sieve[j] = False

        return [i for i, is_prime in enumerate(sieve) if is_prime]

    def rabin_miller_test(self, p, k=5, show_steps=False):
        """
        Тест Рабина–Миллера на простоту с расчетом вероятности
        """
        if p == 2 or p == 3:
            return True
        if p <= 1 or p % 2 == 0:
            return False

        # Разложение p-1 = 2^b * m
        b = 0
        m = p - 1
        while m % 2 == 0:
            m //= 2
            b += 1

        print(f"\n--- Запуск теста Рабина–Миллера для числа {p} ---")
        print(f"Разложение: {p-1} = 2^{b} * {m}")

        passed_tests = 0
        probability_history = []

        for test_num in range(1, k + 1):
            a = random.randint(2, p - 2)
            print(f"\n=== Тест #{test_num}: свидетель a = {a} ===")

            if show_steps:
                z = fast_pow_mod(a, m, p, f"Вычисление a^m mod p")
            else:
                z = pow(a, m, p)
                print(f"Вычисление z = a^m mod p = {a}^{m} mod {p} = {z}")

            # Шаг (3): если z = 1 или z = p-1, тест пройден
            if z == 1 or z == p - 1:
                passed_tests += 1
                error_prob = (1/4) ** passed_tests
                confidence = (1 - error_prob) * 100

                print(f"✓ Тест #{test_num} пройден (z = {z})")
                print(f"  Пройдено тестов: {passed_tests}/{test_num}")
                print(f"  Текущая вероятность простоты: {confidence:.6f}%")
                continue

            j = 0
            test_passed = False

            print(f"Начальное значение z = {z}")
            print(f"Цикл по j от 0 до {b-1}:")

            # Шаг (5): последовательное возведение в квадрат
            while j < b - 1:
                j += 1

                print(f"  j = {j}:")
                
                if show_steps:
                    z_prev = z
                    z = fast_pow_mod(z, 2, p, f"Возведение в квадрат (шаг {j})")
                    print(f"    z = z_prev² mod p = {z_prev}² mod {p} = {z}")
                else:
                    z_prev = z
                    z = pow(z, 2, p)
                    print(f"    z = z_prev² mod p = {z_prev}² mod {p} = {z}")

                # Шаг (4): если j > 0 и z = 1 - число составное
                if j > 0 and z == 1:
                    print(f"✗ Тест #{test_num} провален (j={j}, z=1)")
                    print(f"  Пройдено тестов до провала: {passed_tests}/{test_num}")
                    if passed_tests > 0:
                        final_error_prob = (1/4) ** passed_tests
                        final_confidence = (1 - final_error_prob) * 100
                        print(f"  Итоговая вероятность простоты: {final_confidence:.6f}%")
                    return False

                # Шаг (5): если z = p-1 - тест пройден
                if z == p - 1:
                    passed_tests += 1
                    error_prob = (1/4) ** passed_tests
                    confidence = (1 - error_prob) * 100

                    print(f"✓ Тест #{test_num} пройден (j={j}, z={p-1})")
                    print(f"  Пройдено тестов: {passed_tests}/{test_num}")
                    print(f"  Текущая вероятность простоты: {confidence:.6f}%")
                    test_passed = True
                    break
                else:
                    print(f"    z = {z} ≠ {p-1}, продолжаем...")

            # Шаг (6): если j = b и z ≠ p-1 - число составное
            if not test_passed and z != p - 1:
                print(f"✗ Тест #{test_num} провален (j достигло {b}, z={z} ≠ {p-1})")
                print(f"  Пройдено тестов до провала: {passed_tests}/{test_num}")
                if passed_tests > 0:
                    final_error_prob = (1/4) ** passed_tests
                    final_confidence = (1 - final_error_prob) * 100
                    print(f"  Итоговая вероятность простоты: {final_confidence:.6f}%")
                return False

        # Все тесты пройдены успешно
        final_error_prob = (1/4) ** passed_tests
        final_confidence = (1 - final_error_prob) * 100

        print(f"\n ВСЕ ТЕСТЫ ПРОЙДЕНЫ УСПЕШНО!")
        print(f" Итоговые результаты:")
        print(f"   Пройдено тестов: {passed_tests}/{k}")
        print(f"   Вероятность простоты: {final_confidence:.8f}%")

        return True

    def is_divisible_by_small_primes(self, n):
        """Проверяет делимость на малые простые числа"""
        for prime in self.small_primes:
            if prime >= n:
                break
            if n % prime == 0:
                return True
        return False

    def generate_prime(self, bits):
        """Генерирует простое число заданной битовой длины"""
        while True:
            # Генерация случайного числа заданной длины
            p = random.getrandbits(bits)

            # Устанавливаем старший и младший биты
            p |= (1 << (bits - 1))  # старший бит = 1
            p |= 1  # младший бит = 1 (нечётность)

            if p.bit_length() != bits:
                continue

            # Проверка на делимость малыми простыми
            if self.is_divisible_by_small_primes(p):
                continue

            # Тест Рабина–Миллера
            if self.rabin_miller_test(p, k=5):
                print(f"\n Найдено вероятно простое число: {p}")
                print(f" Битовая длина: {p.bit_length()} бит\n")
                return p


# === Пример использования ===
if __name__ == "__main__":
    generator = PrimeGenerator()

    print("\nГенерация 21-битного простого числа...")
    prime = generator.generate_prime(21)




# Difi_Helman
import random
from math import gcd


# -------------------------
# Быстрое возведение в степень по модулю
# -------------------------
def custom_mod(number: int, step: int, mod: int) -> int:
    p = 1
    while step > 0:
        if step & 1:
            p = (p * number) % mod
        number = (number * number) % mod
        step >>= 1
    return p


# -------------------------
# Тест Миллера–Рабина и генерация простого числа
# -------------------------
class MillerRabin:
    def randomer(self, min_val: int) -> int:
        bits = min_val.bit_length()
        num = random.getrandbits(bits - 2)
        num |= (1 << (bits - 3))
        num = (num << 1) | 1  # сделать нечётным
        return num

    def search_b(self, n: int) -> int:
        acc = n - 1
        b = 0
        while acc % 2 == 0:
            b += 1
            acc //= 2
        return b

    def search_m(self, n: int, b: int) -> int:
        return (n - 1) // (2 ** b)

    def start_examination(self, n: int, b: int, m: int) -> bool:
        for i in range(2, 256):
            if n % i == 0:
                return False

        a = random.randrange(2, n - 1)
        z = custom_mod(a, m, n)

        if z == 1 or z == n - 1:
            return True

        for j in range(1, b + 1):
            z = custom_mod(a, m * (2 ** j), n)
            if z == n - 1:
                return True

        return False

    def create_simple(self) -> int:
        min_val = int('1' + '0' * 21, 2)
        n = self.randomer(min_val)
        b = self.search_b(n)
        m = self.search_m(n, b)

        ver = 1 / 4
        iter_count = 0
        attempts = 0

        print("\n---------------------------------------------\n")
        print(f"Число: {n}")
        print(f"Количество делений на 2: {b}")
        print(f"m: {m}")

        while iter_count != 5:
            iter_count += 1
            attempts += 1

            result = self.start_examination(n, b, m)
            print(f"\nРезультат проверки: {result}")

            if result:
                print(f"Вероятность составного: {ver ** iter_count * 100}%")
            else:
                print("Вероятность составного: 100%")
                if attempts >= 30:
                    print("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
                    print("За 30 попыток не найдено простое число :(")
                    print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n")
                    break

                iter_count = 0
                n += 2
                b = self.search_b(n)
                m = self.search_m(n, b)
                print("---------------------------------------------\n")
                print(f"Число: {n}")
                print(f"Количество делений на 2: {b}")
                print(f"m: {m}")

        print("---------------------------------------------\n")
        print(f"Простое число {n}")
        return n


# -------------------------
# Поиск примитивного элемента
# -------------------------
def find_primitive_element(p: int) -> int:
    current_simple_list = []

    # Функция проверки числа на простоту с помощью Миллера-Рабина
    def is_prime(n: int, tests: int = 5) -> bool:
        if n < 2:
            return False
        if n in (2, 3):
            return True
        if n % 2 == 0:
            return False

        # Находим b и m для n-1 = 2^b * m
        m = n - 1
        b = 0
        while m % 2 == 0:
            b += 1
            m //= 2

        # Проводим tests тестов Миллера-Рабина
        for _ in range(tests):
            a = random.randrange(2, n - 1)
            z = custom_mod(a, m, n)

            if z == 1 or z == n - 1:
                continue

            for j in range(1, b):
                z = custom_mod(z, 2, n)
                if z == n - 1:
                    break
            else:
                return False

        return True

    # Находим простые делители p-1
    temp = p - 1
    divisor = 2


    while divisor * divisor <= temp:
        if temp % divisor == 0:
            # Проверяем, является ли делитель простым
            if is_prime(divisor):
                current_simple_list.append(divisor)
            other_divisor = temp // divisor
            if other_divisor != divisor and is_prime(other_divisor):
                current_simple_list.append(other_divisor)
        divisor += 1

    # Проверяем само число temp, если оно простое
    if temp > 1 and is_prime(temp):
        current_simple_list.append(temp)


    current_simple_list = sorted(list(set(current_simple_list)))

    print(f"Простые делители {p - 1}: {current_simple_list}")

    # Подсчёт примитивных корней
    count_primitive = 0
    for j in range(1, p - 1):
        flag = True
        for q in current_simple_list:
            if j % q == 0:
                flag = False
                break
        if flag:
            count_primitive += 1

    print(f"Количество примитивных корней: {count_primitive}")
    print(f"Тогда доля примитивных корней равна {count_primitive / (p - 1)}")

    primitive = 0
    # Поиск примитивного корня снизу от p//2
    for candidate in range(p // 2, 2, -1):
        primitive = candidate
        for q in current_simple_list:
            if custom_mod(candidate,  q, p) == 1:
                primitive = 0
                break
        if primitive != 0:
            break

    rnd = random.Random()
    while True:
        t = rnd.randrange(2, p - 1)
        if gcd(t, p - 1) == 1:
            print(f"НОД({t} и {p - 1}) = 1")
            a_t_mod_p = pow(primitive, t, p)
            print(
                f"Тогда a^t ≡ {a_t_mod_p} (mod {p}) тоже первообразный корень"
            )
            break

    print(f"Примитивный элемент {primitive}")
    print()
    return primitive
# -------------------------
# Диффи–Хеллман
# -------------------------
def create_open_keys(p: int, g: int) -> dict:
    X = random.randrange(2, p - 1)
    Y = custom_mod(g, X, p)
    return {"X": X, "Y": Y}


def create_close_key(Y: int, X: int, p: int) -> int:
    return custom_mod(Y, X, p)


# -------------------------
# MAIN
# -------------------------
def main():
    simple_generater = MillerRabin()
    p = simple_generater.create_simple()

    g = find_primitive_element(p)

    alice_keys = create_open_keys(p, g)
    print(f"Ключи Алисы: {alice_keys}")

    bob_keys = create_open_keys(p, g)
    print(f"Ключи Боба: {bob_keys}\n")

    alice_secret = create_close_key(bob_keys["Y"], alice_keys["X"], p)
    bob_secret = create_close_key(alice_keys["Y"], bob_keys["X"], p)

    print(f"Секретный ключ Боба: {bob_secret}")
    print(f"Секретный ключ Алисы: {alice_secret}")

    correct_key = create_close_key(g, alice_keys["X"] * bob_keys["X"], p)
    print(f"Правильный ключ: {correct_key}")


if __name__ == "__main__":
    main()




#Ferma
def bigint_sqrt(n: int) -> int:
    """Целочисленный корень."""
    if n < 0:
        raise ValueError("Negative number")
    if n == 0:
        return 0

    x = n
    y = (x + 1) // 2
    while y < x:
        x = y
        y = (x + n // x) // 2
    return x


def is_prime(n: int) -> bool:
    """Простая проверка для факторизации."""
    if n < 2:
        return False
    if n % 2 == 0:
        return n == 2
    i = 3
    while i * i <= n:
        if n % i == 0:
            return False
        i += 2
    return True


def fermat_factor(n: int) -> tuple[int, int] | None:
    """Находит один нетривиальный множитель методом Ферма."""
    if n % 2 == 0:
        return 2, n // 2

    x = bigint_sqrt(n)
    if x * x < n:
        x += 1

    while True:
        t = x * x - n
        if t >= 0:
            y = bigint_sqrt(t)
            if y * y == t:
                a = x - y
                b = x + y
                if a > 1 and b > 1:
                    return a, b
        x += 1

        # защита от бесконечного поиска при простом числе
        if x - bigint_sqrt(n) > 200000:
            return None


def DecompositionFermaBigData(numbers: list[int]) -> list[int]:
    results: list[int] = []

    for n in numbers:
        if n == 1:
            continue

        # Если простое — добавляем сразу
        if is_prime(n):
            results.append(n)
            continue

        # Ищем разложение по Ферма
        factors = fermat_factor(n)

        # если не удалось разложить — число простое
        if factors is None:
            results.append(n)
            continue

        a, b = factors

        # Рекурсивное разложение
        sub = DecompositionFermaBigData([a, b])
        results.extend(sub)

    return results


def main():
    number = 2 * 3 * 7 * 11 * 31 * 43 * 103
    print(f"Число: {number}")

    answer = DecompositionFermaBigData([number])
    print(sorted(answer))


if __name__ == "__main__":
    main()
1076259412231815019865125804167605592839315742411540973272839

#ferma_kotoroe_rabotaet
import math
import random

def fast_multiplication(base, power, modulo):
    DO_LOG = False
    result = 1
    k = 1
    while power > 0:
        s = power % 2
        if s == 1:
            result = (result * base) % modulo
        if DO_LOG: print(f'{k=}, {base=}, {power=}, {s=}, {result=}')
        base = (base * base) % modulo
        power = (power - s) // 2
        k += 1
    return result

def isqrt(n: int) -> int:
    if n == 0:
        return 0

    x = n
    y = (x + 1) // 2

    while y < x:
        x = y
        y = (x + n // x) // 2

    return x


def is_perfect_square(n: int) -> tuple[bool, int]:
    if n < 0:
        return (False, 0)

    root = isqrt(n)
    if root * root == n:
        return (True, root)
    return (False, root)


def fermat_factorization(n: int):
    DO_LOG = False

    if n % 2 == 0:
        if DO_LOG: print(f' [DEBUG] n четное, возвращаем (2, {n // 2})')
        return (2, n // 2)

    for i in range(3, 1000000, 2):
        if n % i == 0:
            if DO_LOG: print(f' [DEBUG] пробное деление {(i, n // i)}')
            return (i, n // i)

    a = isqrt(n)
    if a * a < n:
        a += 1

    if DO_LOG: print(f' [DEBUG] начинаем ферма с a = ceil(sqrt({n})) = {a}')

    max_iterations = 10_000_000
    b_squared = a * a - n

    for iteration in range(max_iterations):
        is_perfect, b = is_perfect_square(b_squared)

        if iteration % 10000 == 0:
            print(a + b, a - b)

        if is_perfect:
            p = a + b
            q = a - b
            if DO_LOG: print(f' [DEBUG] найденные делители: p={p}, q={q}')
            if p * q == n:
                return (p, q)

        a += 1
        b_squared += a*a - n


    if DO_LOG: print(f' [DEBUG] вышли за пределы по итерациям')
    return (None, None)


def find_all_factors(n: int):
    DO_LOG = False

    if DO_LOG: print(f' [DEBUG] ищем все делители {n}')

    if n == 1:
        return []

    if n == 2:
        return [2]

    if rabin_miller_test(n, 10):
        if DO_LOG: print(f' [DEBUG] {n} простое')
        return [n]

    p, q = fermat_factorization(n)

    if p is None:
        print(f" [ERROR] ошибка метода ферма")
        return [n]

    factors = []
    factors.extend(find_all_factors(p))
    factors.extend(find_all_factors(q))

    return sorted(factors)

def rabin_miller_test(p: int, k: int = 5):
    DO_LOG = False
    if p == 2 or p == 3:
        return True
    if p < 2 or p % 2 == 0:
        return False

    p_bin = bin(p - 1)[2:]
    b = 0
    for i in range(len(p_bin) - 1, -1, -1):
        if p_bin[i] == '0':
            b += 1
        else:
            break

    m = (p - 1) // (2 ** b)
    if DO_LOG: print(f' [DEBUG] p={p}, p-1={p-1}, b={b}, m={m}')

    for _ in range(k):
        a = random.randint(2, p - 2)
        if DO_LOG: print(f' [DEBUG] Round: a={a}')

        z = fast_multiplication(a, m, p)
        if DO_LOG: print(f' [DEBUG] z = a^m mod p = {z}')

        if z == 1 or z == p - 1:
            if DO_LOG: print(f' [DEBUG] z={z}, continuing to next round')
            continue

        for _ in range(b - 1):
            z = fast_multiplication(z, 2, p)
            if DO_LOG: print(f' [DEBUG] Squaring: z={z}')
            if z == p - 1:
                break
        else:
            if DO_LOG: print(f' [DEBUG] Never found p-1, p is composite')
            return False

    return True

if __name__ == '__main__':
   item=1076259412231815019865125804167605592839315742411540973272839;
   print(f' {find_all_factors(item)}')






#elliptic_curve
# elliptic_curve_correct.py
import random
import math

# =========================================================
# Miller–Rabin (нормальный вероятностный тест простоты)
# =========================================================

def is_probable_prime(n, k=10):
    if n in (2, 3):
        return True
    if n < 2 or n % 2 == 0:
        return False

    # n-1 = d * 2^s
    d = n - 1
    s = 0
    while d % 2 == 0:
        d //= 2
        s += 1

    for _ in range(k):
        a = random.randrange(2, n - 1)
        x = pow(a, d, n)
        if x in (1, n - 1):
            continue
        for __ in range(s - 1):
            x = (x * x) % n
            if x == n - 1:
                break
        else:
            return False
    return True


def next_prime(start):
    p = start if start % 2 else start + 1
    while True:
        print("Тестируемое число", p)
        if is_probable_prime(p):
            return p
        print("Тест не пройден, число составное")
        p += 2


# =========================================================
# Эллиптическая кривая: y^2 = x^3 + x (mod p)
# =========================================================

O = None  # точка на бесконечности

def inv_mod(a, p):
    a %= p
    if a == 0:
        raise ZeroDivisionError("Обратного элемента не существует")
    return pow(a, p - 2, p)  # p простое


def add_points(P, Q, p):
    # Работаем с точкой на бесконечности правильно
    if P is None:
        return Q
    if Q is None:
        return P

    x1, y1 = P
    x2, y2 = Q

    # P + (-P) = O
    if x1 == x2 and (y1 + y2) % p == 0:
        return None

    if P != Q:
        lam = ((y2 - y1) * inv_mod(x2 - x1, p)) % p
    else:
        # удвоение: lam = (3x^2 + 1) / (2y)
        if y1 % p == 0:
            return None
        lam = ((3 * x1 * x1 + 1) * inv_mod(2 * y1, p)) % p

    x3 = (lam * lam - x1 - x2) % p
    y3 = (lam * (x1 - x3) - y1) % p
    return (x3, y3)


def mul(k, P, p):
    """Скалярное умножение (double-and-add)."""
    R = None
    A = P
    while k > 0:
        if k & 1:
            R = add_points(R, A, p)
        A = add_points(A, A, p)
        k >>= 1
    return R


def on_curve(P, p):
    if P is None:
        return True
    x, y = P
    return (y*y - (x*x*x + x)) % p == 0


def find_point(p):
    """Ищем любую точку на кривой перебором (просто и понятно)."""
    for x in range(1, p):
        rhs = (x*x*x + x) % p
        for y in range(1, p):
            if (y*y) % p == rhs:
                return (x, y)
    return None


# =========================================================
# #E(F_p) и проверка Хассе
# =========================================================

def legendre_symbol(a, p):
    """(a|p) = -1,0,1"""
    a %= p
    if a == 0:
        return 0
    t = pow(a, (p - 1) // 2, p)
    return -1 if t == p - 1 else 1


def count_points(p):
    """
    #E(F_p) = p + 1 + sum_{x=0..p-1} (x^3 + x | p)
    """
    s = 0
    for x in range(p):
        rhs = (x*x*x + x) % p
        s += legendre_symbol(rhs, p)
    return p + 1 + s


def hasse_check(N, p):
    bound = 2 * math.isqrt(p)
    return abs(N - (p + 1)) <= bound, bound


# =========================================================
# main
# =========================================================

def main():
    start = 1613
    p = next_prime(start)
    print("\nПростое число:", p)

    # порядок точки на бесконечности
    print("Порядок точки O (бесконечности):", 1)

    P = find_point(p)
    print("Найдена точка P:", P)
    print("P на кривой?", on_curve(P, p))

    # Удвоения: 2P,4P,...,128P
    Q = P
    for n in [2, 4, 8, 16, 32, 64, 128]:
        Q = add_points(Q, Q, p)
        print(f"{n}P = {Q}")
        if Q is None:
            print("Достигнута точка на бесконечности (O). Порядок точки делит", n)
            break

    # 151P (правильно)
    P151 = mul(151, P, p)
    print("151P =", P151)

    # Хассе (правильно: через N = #E(F_p))
    N = count_points(p)
    ok, bound = hasse_check(N, p)
    print("#E(F_p) =", N)
    print("p+1 =", p + 1, " |N-(p+1)| =", abs(N - (p + 1)), " <= 2*sqrt(p) =", bound)
    print("Теорема Хассе выполняется?", ok)


if __name__ == "__main__":
    main()
